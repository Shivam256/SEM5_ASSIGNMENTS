<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1>READER WRITER MUTEX</h1>
    <div>
        #include-stdio.h-
        #include-pthread.h-
        #include-string.h-
        int hours=23,mins=59,secs=53;
        void update();
        void display();
        pthread_mutex_t timer_lock;
        int main(void)
        {
            void *status;
            pthread_t r_thr,w_thr;
            pthread_mutex_init(&timer_lock,0);
            pthread_create(&r_thr,NULL,(void *)&display,(void *)NULL);
            pthread_create(&w_thr,NULL,(void *)&update,(void *)NULL);
            pthread_join(r_thr,&status);
            pthread_join(w_thr,&status);
        }
        
        void update()
        {
            void *status;
            while(1)
            {
                pthread_mutex_lock(&timer_lock);
                secs=secs+1;
                if(secs==60)
                {
                        mins=mins+1;
                        secs=0;
                }
                if(mins==60)
                {
                        hours=hours+1;
                        mins=0;
                }
                if(hours==24)
                {
                        hours=0;
                }
            pthread_mutex_unlock(&timer_lock);
            sleep(1);
            }
            pthread_exit(&status);
        }
        
        void display()
        {
            void *status;
            while(1)
            {
                pthread_mutex_lock(&timer_lock);
                printf("\n DISPLAY:");
                printf("\t %d %d %d",hours,mins,secs);
                pthread_mutex_unlock(&timer_lock);
                // sleep(1);
            }
            pthread_exit(&status);
        }
    </div>
    <h1>PRODUCER CONSUMER MUTEX</h1>
    <div>
        #include-stdio.h-
        #include-pthread.h-
        #include-string.h-
        #include-semaphore.h-
        
        char buffer[20];
        void *produce();
        void *consume();
        pthread_mutex_t mut;
        
        int main()
        {
            void *status;
            pthread_t p_thr,c_thr;
            pthread_mutex_init(&mut,0);
            pthread_create(&p_thr,NULL,(void*)&produce,NULL);
            pthread_create(&c_thr,NULL,(void*)&consume,NULL);
            pthread_join(p_thr,&status);
            pthread_join(c_thr,&status);
            return 0;
        }
        
        void *produce()
        {
            char str[20];
        
            while(1)
            {    
                    
                pthread_mutex_lock(&mut);
                    printf("\nENTER A STRING:");
            scanf("%s",str);
        
                strcpy(buffer,str);
                pthread_mutex_unlock(&mut);
                sleep(1);
            }
        
        }
        
        void *consume()
        {
                char str1[20];
        
                while(1)
                {
                    pthread_mutex_lock(&mut);
                    strcpy(str1,buffer);
                    printf("\nTHE CONSUMED STRING IS :%s",str1);
                    pthread_mutex_unlock(&mut);
                    sleep(1);
                }
        
        }
    </div>
    <h1>READER WRITER SEMAPHORE</h1>
    <div>
        #include -stdio.h-
        #include -pthread.h>
        #include -semaphore.h-
        #include -unistd.h-
        sem_t r, w;
        int h = 23, m = 59, s = 55;
        void *reader(), *writer();
        int main()
        {
            pthread_t rth, wth;
            void *status;
            sem_init(&r, 0, 0);
            sem_init(&w, 0, 1);
        
            pthread_create(&rth, NULL, (void *)&reader, NULL);
            pthread_create(&wth, NULL, (void *)&writer, NULL);
            pthread_join(rth, status);
            pthread_join(wth, status);
            sem_destroy(&w);
            sem_destroy(&r);
        }
        
        void *writer()
        {
            while (1)
            {
                sem_wait(&w);
                s = s + 1;
                if (s == 60)
                {
                    m++;
                    s = 0;
                }
                if (m == 60)
                {
                    h++;
                    m = 0;
                }
                if (h == 24)
                {
                    h = 1;
                }
                // sleep(1);
                sem_post(&r);
            }
        }
        
        void *reader()
        {
            while (1)
            {
                sem_wait(&r);
                printf("\n Display:\t");
                printf("%d:%d:%d", h, m, s);
                sem_post(&w);
            }
        }
    </div>
    <h1>PRODUCER CONSUMER SEMAPHORE</h1>
    <div>
        #include-stdio.h-
        #include-semaphore.h-
        #include-pthread.h-
        
        pthread_t producer_thr;
        pthread_t consumer_thr;
        sem_t full;
        sem_t empty;
        sem_t mutex;
        int buf[3],item_no=0,buf_index=0; 
        
        void *producer(){   
            int cntr;
            for(cntr=0;cntr< 5;cntr++){
                printf("Producer produced item %d\n",item_no);
                printf("Producer is checking if basket is having space\n");	
        
                if(buf_index==3)
                    printf("Producer cannot insert as basket is full\n");
        
                sem_wait(&empty);
            
                sem_wait(&mutex);
                printf("Producer is inserting item %d in the basket\n",item_no);
                buf[buf_index]=item_no;
                buf_index++;
                item_no++;
                sem_post(&mutex);
        
                sem_post(&full);
            }
        }
        void *consumer(){
            int item,cntr;
            for(cntr=0;cntr< 5;cntr++){
                printf("\tConsumer is checking if buffer is having an item\n");	
        
                if(buf_index==0)
                    printf("\tConsumer cannot consume as buffer is empty\n");
            
                sem_wait(&full);
            
                sem_wait(&mutex);
                item=buf[buf_index];
                printf("\tConsumer is removing item %d from the basket\n",item);
                buf_index--;
                sleep(3);
                sem_post(&mutex);
        
                sem_post(&empty);
            }
        }
        
        void main(){
            sem_init(&mutex,0,1);
            sem_init(&full,0,0);
            sem_init(&empty,0,3);
        
            pthread_create(&producer_thr,NULL,producer,NULL);
            pthread_create(&consumer_thr,NULL,consumer,NULL);
            
            pthread_join(producer_thr,NULL);
            pthread_join(consumer_thr,NULL);
        }
    </div>
    <h1>DINING PHILOSOPHER SEMAPHORE</h1>
    <div>
        #include -stdio.h-
        #include -stdlib.h-
        #include -pthread.h-
        #include -semaphore.h-
        #define NUM_PHILOSOPHERS 5
        #define NUM_CHOPSTICKS 5
        
        void dine(int n);
        pthread_t philosopher[NUM_PHILOSOPHERS];
        pthread_mutex_t chopstick[NUM_CHOPSTICKS];
        
        int main()
        {
            int i, status_message;
            void *msg;
        
            for (i = 1; i <= NUM_CHOPSTICKS; i++)
            {
            status_message = pthread_mutex_init(&chopstick[i], NULL);
            if (status_message == -1)
            {
                printf("\n Mutex initialization failed");
                exit(1);
            }
            }
        
            for (i = 1; i <= NUM_PHILOSOPHERS; i++)
            {
            status_message = pthread_create(&philosopher[i], NULL, (void *)dine, (int *)i);
            if (status_message != 0)
            {
                printf("\n Thread creation error \n");
                exit(1);
            }
            }
        
            for (i = 1; i <= NUM_PHILOSOPHERS; i++)
            {
            status_message = pthread_join(philosopher[i], &msg);
            if (status_message != 0)
            {
                printf("\n Thread join failed \n");
                exit(1);
            }
            }
        
            for (i = 1; i <= NUM_CHOPSTICKS; i++)
            {
            status_message = pthread_mutex_destroy(&chopstick[i]);
            if (status_message != 0)
            {
                printf("\n Mutex Destroyed \n");
                exit(1);
            }
            }
            return 0;
        }
        void dine(int n)
        {
            printf("\nPhilosopher % d is thinking ", n);
        
            pthread_mutex_lock(&chopstick[n]);
        
            pthread_mutex_lock(&chopstick[(n + 1) % NUM_CHOPSTICKS]);
        
            printf("\nPhilosopher % d is eating ", n);
            sleep(3);
        
            pthread_mutex_unlock(&chopstick[n]);
        
            pthread_mutex_unlock(&chopstick[(n + 1) % NUM_CHOPSTICKS]);
        
            printf("\nPhilosopher % d Finished eating ", n);
        }
    </div>
    <h1>FCFS</h1>
    <div>
        #include -iostream-
        using namespace std;
            
        void findWaitingTime(int processes[], int n,
                            int bt[], int wt[])
        {
            
            wt[0] = 0;
            
            for (int i = 1; i < n; i++)
                wt[i] = bt[i - 1] + wt[i - 1];
        }
        void findTurnAroundTime(int processes[], int n,
                                int bt[], int wt[], int tat[])
        {
            
            for (int i = 0; i < n; i++)
                tat[i] = bt[i] + wt[i];
        }
            
        void findavgTime(int processes[], int n, int bt[])
        {
            int wt[n], tat[n], total_wt = 0, total_tat = 0;
            
            findWaitingTime(processes, n, bt, wt);
            
            findTurnAroundTime(processes, n, bt, wt, tat);
            
            cout << "Processes  "
                << " Burst time  "
                << " Waiting time  "
                << " Turn around time\n";
            
            for (int i = 0; i < n; i++)
            {
                total_wt = total_wt + wt[i];
                total_tat = total_tat + tat[i];
                cout << "   " << i + 1 << "\t\t" << bt[i] << "\t    "
                    << wt[i] << "\t\t  " << tat[i] << endl;
            }
            
            cout << "Average waiting time = "
                << (float)total_wt / (float)n;
            cout << "\nAverage turn around time = "
                << (float)total_tat / (float)n;
        }
            
        int main()
        {
            
            int processes[] = {1, 2, 3};
            int n = sizeof processes / sizeof processes[0];
            
            int burst_time[] = {10, 5, 8};
            
            findavgTime(processes, n, burst_time);
            return 0;
        }
    </div>
    <h1>SJF</h1>
    <div>
        #include -stdio.h-
        int main()
        {
            int A[100][4];
            int i, j, n, total = 0, index, temp;
            float avg_wt, avg_tat;
            printf("Enter number of process: ");
            scanf("%d", &n);
            printf("Enter Burst Time:\n");
        
            for (i = 0; i < n; i++)
            {
                printf("P%d: ", i + 1);
                scanf("%d", &A[i][1]);
                A[i][0] = i + 1;
            }
        
            for (i = 0; i < n; i++)
            {
                index = i;
                for (j = i + 1; j < n; j++)
                    if (A[j][1] < A[index][1])
                        index = j;
                temp = A[i][1];
                A[i][1] = A[index][1];
                A[index][1] = temp;
        
                temp = A[i][0];
                A[i][0] = A[index][0];
                A[index][0] = temp;
            }
            A[0][2] = 0;
        
            for (i = 1; i < n; i++)
            {
                A[i][2] = 0;
                for (j = 0; j < i; j++)
                    A[i][2] += A[j][1];
                total += A[i][2];
            }
            avg_wt = (float)total / n;
            total = 0;
            printf("P     BT     WT     TAT\n");
        
            for (i = 0; i < n; i++)
            {
                A[i][3] = A[i][1] + A[i][2];
                total += A[i][3];
                printf("P%d     %d     %d      %d\n", A[i][0],
                        A[i][1], A[i][2], A[i][3]);
            }
            avg_tat = (float)total / n;
            printf("Average Waiting Time= %f", avg_wt);
            printf("\nAverage Turnaround Time= %f", avg_tat);
        }
    </div>
    <h1>ROUND ROBIN</h1>
    <div>
        #include -iostream-
        using namespace std;
        
        void findWaitingTime(int processes[], int n,
                                int bt[], int wt[], int quantum)
        {
        
            int rem_bt[n];
            for (int i = 0; i < n; i++)
                rem_bt[i] = bt[i];
        
            int t = 0;
        
            while (1)
            {
                bool done = true;
        
                for (int i = 0; i < n; i++)
                {
        
                    if (rem_bt[i] > 0)
                    {
                        done = false;
        
                        if (rem_bt[i] > quantum)
                        {
        
                            t += quantum;
        
                            rem_bt[i] -= quantum;
                        }
        
                        else
                        {
        
                            t = t + rem_bt[i];
        
                            wt[i] = t - bt[i];
        
                            rem_bt[i] = 0;
                        }
                    }
                }
        
                if (done == true)
                    break;
            }
        }
        void findTurnAroundTime(int processes[], int n,
                                int bt[], int wt[], int tat[])
        {
        
            for (int i = 0; i < n; i++)
                tat[i] = bt[i] + wt[i];
        }
        
        void findavgTime(int processes[], int n, int bt[],
                            int quantum)
        {
            int wt[n], tat[n], total_wt = 0, total_tat = 0;
        
            findWaitingTime(processes, n, bt, wt, quantum);
        
            findTurnAroundTime(processes, n, bt, wt, tat);
        
            cout << "PN\t "
                    << " \tBT "
                    << "  WT "
                    << " \tTAT\n";
        
            for (int i = 0; i < n; i++)
            {
                total_wt = total_wt + wt[i];
                total_tat = total_tat + tat[i];
                cout << " " << i + 1 << "\t\t" << bt[i] << "\t "
                        << wt[i] << "\t\t " << tat[i] << endl;
            }
        
            cout << "Average waiting time = "
                    << (float)total_wt / (float)n;
            cout << "\nAverage turn around time = "
                    << (float)total_tat / (float)n;
        }
        
        int main()
        {
        
            int processes[] = {1, 2, 3};
            int n = sizeof processes / sizeof processes[0];
        
            int burst_time[] = {10, 5, 8};
        
            int quantum = 2;
            findavgTime(processes, n, burst_time, quantum);
            return 0;
        }
    </div>
    <h1>PRIORITY SCHEDULING</h1>
    <div>
        #include-bits/stdc++.h-
        using namespace std;
        
        struct Process
        {
            int pid;  // Process ID
            int bt;   // CPU Burst time required
            int priority; // Priority of this process
        };
        
        // Function to sort the Process acc. to priority
        bool comparison(Process a, Process b)
        {
            return (a.priority > b.priority);
        }
        
        // Function to find the waiting time for all
        // processes
        void findWaitingTime(Process proc[], int n,
                            int wt[])
        {
            // waiting time for first process is 0
            wt[0] = 0;
        
            // calculating waiting time
            for (int  i = 1; i < n ; i++ )
                wt[i] =  proc[i-1].bt + wt[i-1] ;
        }
        
        // Function to calculate turn around time
        void findTurnAroundTime( Process proc[], int n,
                                int wt[], int tat[])
        {
            // calculating turnaround time by adding
            // bt[i] + wt[i]
            for (int  i = 0; i < n ; i++)
                tat[i] = proc[i].bt + wt[i];
        }
        
        //Function to calculate average time
        void findavgTime(Process proc[], int n)
        {
            int wt[n], tat[n], total_wt = 0, total_tat = 0;
        
            //Function to find waiting time of all processes
            findWaitingTime(proc, n, wt);
        
            //Function to find turn around time for all processes
            findTurnAroundTime(proc, n, wt, tat);
        
            //Display processes along with all details
            cout << "\nProcesses  "<< " Burst time  "
                << " Waiting time  " << " Turn around time\n";
        
            // Calculate total waiting time and total turn
            // around time
            for (int  i=0; i< n; i++)
            {
                total_wt = total_wt + wt[i];
                total_tat = total_tat + tat[i];
                cout << "   " << proc[i].pid << "\t\t"
                    << proc[i].bt << "\t    " << wt[i]
                    << "\t\t  " << tat[i] << endl;
            }
        
            cout << "\nAverage waiting time = "
                << (float)total_wt / (float)n;
            cout << "\nAverage turn around time = "
                << (float)total_tat / (float)n;
        }
        
        void priorityScheduling(Process proc[], int n)
        {
            // Sort processes by priority
            sort(proc, proc + n, comparison);
        
            cout<< "Order in which processes gets executed \n";
            for (int  i = 0 ; i <  n; i++)
                cout << proc[i].pid <<" " ;
        
            findavgTime(proc, n);
        }
        
        // Driver code
        int main()
        {
            Process proc[] = {{1, 10, 2}, {2, 5, 0}, {3, 8, 1}};
            int n = sizeof proc / sizeof proc[0];
            priorityScheduling(proc, n);
            return 0;
        }
    </div>
    <h1>Bankers algo</h1>
    <div>
        #include -iostream-
        using namespace std;
            
        int main()
        {
            
            int n, m, i, j, k;
            n = 5;
            m = 3;
            int alloc[5][3] = {{0, 1, 0},
                                {2, 0, 0},
                                {3, 0, 2},
                                {2, 1, 1},
                                {0, 0, 2}};
            
            int max[5][3] = {{7, 5, 3},
                            {3, 2, 2},
                            {9, 0, 2},
                            {2, 2, 2},
                            {4, 3, 3}};
            
            int avail[3] = {3, 3, 2};
            
            int f[n], ans[n], ind = 0;
            for (k = 0; k < n; k++)
            {
                f[k] = 0;
            }
            int need[n][m];
            for (i = 0; i < n; i++)
            {
                for (j = 0; j < m; j++)
                    need[i][j] = max[i][j] - alloc[i][j];
            }
            int y = 0;
            for (k = 0; k < 5; k++)
            {
                for (i = 0; i < n; i++)
                {
                    if (f[i] == 0)
                    {
            
                        int flag = 0;
                        for (j = 0; j < m; j++)
                        {
                            if (need[i][j] > avail[j])
                            {
                                flag = 1;
                                break;
                            }
                        }
            
                        if (flag == 0)
                        {
                            ans[ind++] = i;
                            for (y = 0; y < m; y++)
                                avail[y] += alloc[i][y];
                            f[i] = 1;
                        }
                    }
                }
            }
            
            int flag = 1;
            
            for (int i = 0; i < n; i++)
            {
                if (f[i] == 0)
                {
                    flag = 0;
                    cout << "The given sequence is not safe";
                    break;
                }
            }
            
            if (flag == 1)
            {
                cout << "Following is the SAFE Sequence" << endl;
                for (i = 0; i < n - 1; i++)
                    cout << " P" << ans[i] << " ->";
                cout << " P" << ans[n - 1] << endl;
            }
            
            return (0);
        }
    </div>
    <h1>PAGE REPLACEMENT FCFS</h1>
    <div>
        #include-bits/stdc++.h-
        using namespace std;
        int pageFaults(int pages[], int n, int capacity)
        {
        
        unordered_set<int> s;
        queue<int> indexes;
        
        int page_faults = 0;
        for (int i=0; i< n; i++)
        {
            if (s.size() < capacity)
            {
                
                if (s.find(pages[i])==s.end())
                {
                    
                    s.insert(pages[i]);
                        page_faults++;
                    indexes.push(pages[i]);
                }
            }
            else
            {   
                if (s.find(pages[i]) == s.end())
                {
                    int val = indexes.front();
                    indexes.pop();
                    s.erase(val);
                    s.insert(pages[i]);
                    indexes.push(pages[i]);
                    page_faults++;
                }
            }
        }
        return page_faults;
        }
        int main()
        {
        int pages[] = {7, 0, 1, 2, 0, 3, 0, 4,
                        2, 3, 0, 3, 2};
        int n = sizeof(pages)/sizeof(pages[0]);
        int capacity = 4;
        cout << pageFaults(pages, n, capacity);
        return 0;
        }
    </div>
    <h1>PAGE REPLACEMENT LRU</h1>
    <div>
        #include -bits/stdc++.h-
        using namespace std;
        
        int pageFaults(int pages[], int n, int capacity)
        {
        
        unordered_set<int> s;
        
        unordered_map<int, int> indexes;
        
        int page_faults = 0;
        for (int i = 0; i < n; i++)
        {
            if (s.size() < capacity)
            {
        
                if (s.find(pages[i]) == s.end())
                {
                    s.insert(pages[i]);
        
                    page_faults++;
                }
        
                indexes[pages[i]] = i;
            }
        
            else
            {
        
                if (s.find(pages[i]) == s.end())
                {
        
                    int lru = INT_MAX, val;
                    for (auto it = s.begin(); it != s.end(); it++)
                    {
                        if (indexes[*it] < lru)
                        {
                            lru = indexes[*it];
                            val = *it;
                        }
                    }
        
                    s.erase(val);
        
                    s.insert(pages[i]);
        
                    page_faults++;
                }
        
                indexes[pages[i]] = i;
            }
        }
        
        return page_faults;
        }
        
        int main()
        {
        int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
        int n = sizeof(pages) / sizeof(pages[0]);
        int capacity = 4;
        cout << pageFaults(pages, n, capacity);
        return 0;
        }
    </div>
    <h1>OPTIMAL PAGE</h1>
    <div>int main()
        {
           int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos, max, faults = 0;
           printf("Enter number of frames: ");
           scanf("%d", &no_of_frames);
         
           printf("Enter number of pages: ");
           scanf("%d", &no_of_pages);
         
           printf("Enter page reference string: ");
         
           for (i = 0; i < no_of_pages; ++i)
           {
               scanf("%d", &pages[i]);
           }
         
           for (i = 0; i < no_of_frames; ++i)
           {
               frames[i] = -1;
           }
         
           for (i = 0; i < no_of_pages; ++i)
           {
               flag1 = flag2 = 0;
         
               for (j = 0; j < no_of_frames; ++j)
               {
                   if (frames[j] == pages[i])
                   {
                       flag1 = flag2 = 1;
                       break;
                   }
               }
         
               if (flag1 == 0)
               {
                   for (j = 0; j < no_of_frames; ++j)
                   {
                       if (frames[j] == -1)
                       {
                           faults++;
                           frames[j] = pages[i];
                           flag2 = 1;
                           break;
                       }
                   }
               }
         
               if (flag2 == 0)
               {
                   flag3 = 0;
         
                   for (j = 0; j < no_of_frames; ++j)
                   {
                       temp[j] = -1;
         
                       for (k = i + 1; k < no_of_pages; ++k)
                       {
                           if (frames[j] == pages[k])
                           {
                               temp[j] = k;
                               break;
                           }
                       }
                   }
         
                   for (j = 0; j < no_of_frames; ++j)
                   {
                       if (temp[j] == -1)
                       {
                           pos = j;
                           flag3 = 1;
                           break;
                       }
                   }
         
                   if (flag3 == 0)
                   {
                       max = temp[0];
                       pos = 0;
         
                       for (j = 1; j < no_of_frames; ++j)
                       {
                           if (temp[j] > max)
                           {
                               max = temp[j];
                               pos = j;
                           }
                       }
                   }
                   frames[pos] = pages[i];
                   faults++;
               }
         
               printf("\n");
         
               for (j = 0; j < no_of_frames; ++j)
               {
                   printf("%d\t", frames[j]);
               }
           }
         
           printf("\n\nTotal Page Faults = %d", faults);
         
           return 0;
        }
        </div>
        <h1>SHELL SORT</h1>
        <div>
            # Sorting the array in Bash 
            # using Bubble sort

            # Static input of Array
            arr=(10 8 20 100 12)

            echo "Array in original order"
            echo ${arr[*]}

            # Performing Bubble sort 
            for ((i = 0; i< 5; i++))
            do
                
                for((j = 0; j< 5-i-1; j++))
                do
                
                    if [ ${arr[j]} -gt ${arr[$((j+1))]} ]
                    then
                        # swap
                        temp=${arr[j]}
                        arr[$j]=${arr[$((j+1))]}  
                        arr[$((j+1))]=$temp
                    fi
                done
            done

            echo "Array in sorted order :"
            echo ${arr[*]}
        </div>
        <h1>SHELL PRIME AND REVERSE</h1>
        <div>
            number=53
            i=2
            flag=0
            while test $i -le `expr $number / 2`
            do
            if test `expr $number % $i` -eq 0
            then
            flag=1
            fi

            i=`expr $i + 1`
            done if test $flag -eq 1
            then
            echo "The number is Not Prime"
            else
            echo "The number is Prime"
            Fi

            #reverse the number
            echo enter n
            read n
            num=0
            while [ $n -gt 0 ]
            do
            num=$(expr $num \* 10)
            k=$(expr $n % 10)
            num=$(expr $num + $k)
            n=$(expr $n / 10)
            done
            echo number is $num
        </div>
        <h1>SHELL PALINDROME</h1>
        <div>
            #! /bin/bash
            #Website : cs.sounak.in
            # Author: Sounak Pal
            ## Script to check a number palindrome or not
            echo &quot;Enter a Number&quot;
            read n
            temp=$n
            while ((temp>0))
            do
                ans=$((ans*10))
                mod=$((temp%10))
                ans=$((ans+mod))
                temp=$((temp/10))
            done
            if (($n == $ans))
            then
                echo "It's a Palindrome Number"
            else
            echo "It's not a Palindrome Number"
            fi
        </div>
        <h1>SHELL FACTORIAL</h1>
        <div>
            #withour recursion
            echo "Enter a number"
            read num

            fact=1

            while [ $num -gt 1 ]
            do
            fact=$((fact * num))  #fact = fact * num
            num=$((num - 1))      #num = num - 1
            done

            echo $fact



            #with recursion
            #!/bin/bash
            # Recursive factorial function

            factorial()
            {
                product=$1
                    
                # Defining a function to calculate factorial using recursion
                if((product <= 2)); then
                    echo $product
                else
                    f=$((product -1))
                    
            # Recursive call

            f=$(factorial $f)
            f=$((f*product))
            echo $f
            fi
            }

            # main program
            # reading the input from user
            echo "Enter the number:"   
            read num

            # defining a special case for 0! = 1
            if((num == 0)); then   
            echo 1
            else
            #calling the function
            factorial $num
            fi

        </div>
        <h1>OS CP</h1>
        <div>
            #include -iostream-
            #include -fstream-
            #include -string.h-
            #include -cstdlib-
            #include -time.h-
            #include -vector-
            using namespace std;
            
            ifstream fin("input.txt");
            ofstream fout("output.txt");
            
            char M[300][4], buffer[40], IR[4], R[4];
            int IC, C, SI, PI, TI, PTR, TTC, LLC;
            bool flagBreak;   // To indicate current job is terminated
            vector<int> allo; // To check repeat allocation in PTR
            
            struct PCB
            {
                int job_id;
                int TTL;
                int TLL;
            
                void setPCB(int id, int ttl, int tll)
                {
                    job_id = id;
                    TTL = ttl;
                    TLL = tll;
                }
            };
            
            PCB pcb;
            
            string error[9] = {"No Error", "Out of Data", "Line Limit Exceeded", "Time Limit Exceeded",
                                "Operation Code Error", "Operand Error", "Invalid Page Fault", "Time Limit Exceeded with opcode error", "Time Limit Exceeded with operand error"};
            
            void INIT();
            void READ(int RA);
            void WRITE(int RA);
            int ADDRESSMAP(int VA);
            void EXECUTE_USER_PROGRAM();
            void STARTEXECUTION();
            int ALLOCATE();
            void LOAD();
            
            void INIT()
            {
                memset(M, '\0', 1200);
                memset(IR, '\0', 4);
                memset(R, '\0', 4);
                C = 0;
                SI = 0;
                PI = 0;
                TI = 0;
                flagBreak = false;
            }
            
            void TERMINATE(int EM)
            {
                fout << endl;
                fout << "Job ID : " << pcb.job_id << endl
                        << error[EM] << endl;
                fout << "IC : " << IC << endl
                        << "IR : ";
                for (int i = 0; i < 4; i++)
                    fout << IR[i];
            
                fout << endl
                        << "TTC : " << TTC << endl
                        << "LLC : " << LLC;
                fout << endl
                        << endl;
            }
            
            void READ(int RA)
            {
                fin.getline(buffer, 41);
            
                char temp[5];
                memset(temp, '\0', 5);
                memcpy(temp, buffer, 4);
            
                if (!strcmp(temp, "$END"))
                {
                    TERMINATE(1);
                    flagBreak = true;
                }
                else
                {
                    strcpy(M[RA], buffer);
                }
            }
            
            void WRITE(int RA)
            {
                if (LLC + 1 > pcb.TLL)
                {
                    TERMINATE(2);
                    flagBreak = true;
                }
                else
                {
                    string str; //! Changed to string
                    int k = 0;
                    for (int i = RA; i < (RA + 10); i++)
                    {
                        for (int j = 0; j < 4; j++)
                            str += M[i][j];
                    }
                    fout << str << endl;
                    LLC++;
                }
            }
            
            int MOS(int RA = 0)
            {
                if (TI == 0)
                {
                    if (SI != 0)
                    {
                        switch (SI)
                        {
                        case 1:
                            READ(RA);
                            break;
                        case 2:
                            WRITE(RA);
                            break;
                        case 3:
                            TERMINATE(0);
                            flagBreak = true;
                            break;
                        default:
                            cout << "Error with SI." << endl;
                        }
                        SI = 0;
                    }
                    // Page Fault checking
                    else if (PI != 0)
                    {
                        switch (PI)
                        {
                        case 1:
                            TERMINATE(4);
                            flagBreak = true;
                            break;
                        case 2:
                            TERMINATE(5);
                            flagBreak = true;
                            break;
                        case 3:
                            PI = 0;
                            char temp[3];
                            memset(temp, '\0', 3);
                            memcpy(temp, IR, 2);
                            // valid page fault
                            if (!strcmp(temp, "GD") || !strcmp(temp, "SR"))
                            {
                                int m;
                                do
                                {
                                    m = ALLOCATE();
                                } while (M[m * 10][0] != '\0');
                                int currPTR = PTR;
                                while (M[currPTR][0] != '0')
                                    currPTR++;
            
                                char temp1[2];
                                sprintf(temp1, "%d", m);
                                M[currPTR][0] = '1';
            
                                if (m < 10)
                                {
                                    M[currPTR][2] = '0';
                                    M[currPTR][3] = temp1[0];
                                }
                                else
                                {
                                    M[currPTR][2] = temp1[0];
                                    M[currPTR][3] = temp1[1];
                                }
            
                                if (TTC + 1 > pcb.TTL)
                                {
                                    TI = 2;
                                    PI = 3;
                                    MOS();
                                    break;
                                }
                                return 1;
                            }
                            else if (!strcmp(temp, "PD") || !strcmp(temp, "LR") || !strcmp(temp, "H") || !strcmp(temp, "CR") || !strcmp(temp, "BT"))
                            {
                                TERMINATE(6);
                                flagBreak = true;
            
                                if (TTC + 1 > pcb.TTL)
                                {
                                    TI = 2;
                                    PI = 3;
                                    MOS();
                                    break;
                                }
                            }
                            else
                            {
                                PI = 1;
                                MOS();
                            }
                            return 0;
                        default:
                            cout << "Error with PI." << endl;
                        }
                        PI = 0;
                    }
                }
                else
                {
                    if (SI != 0)
                    {
                        switch (SI)
                        {
                        case 1:
                            TERMINATE(3);
                            flagBreak = true;
                            break;
                        case 2:
                            WRITE(RA);
                            if (!flagBreak)
                                TERMINATE(3);
                            flagBreak = true; //! check
                            break;
                        case 3:
                            TERMINATE(0);
                            flagBreak = true;
                            break;
                        default:
                            cout << "Error with SI." << endl;
                        }
                        SI = 0;
                    }
                    else if (PI != 0)
                    {
                        switch (PI)
                        {
                        case 1:
                            TERMINATE(7);
                            flagBreak = true;
                            break;
                        case 2:
                            TERMINATE(8);
                            flagBreak = true;
                            break;
                        case 3:
                            TERMINATE(3);
                            flagBreak = true;
                            break;
                        default:
                            cout << "Error with PI." << endl;
                        }
                        PI = 0;
                    }
                }
            
                return 0;
            }
            
            void increment()
            {
                TTC++;
                if (TTC + 1 > pcb.TTL)
                {
                    TI = 2;
                }
            }
            
            int ADDRESSMAP(int VA)
            {
                if (0 <= VA && VA < 100)
                {
                    int pte = PTR + VA / 10; // 112
            
                    if (M[pte][0] == '0')
                    {
                        PI = 3;
                        return 0;
                    }
            
                    char temp[2];
                    temp[0] = M[pte][2];
                    temp[1] = M[pte][3];
                    int RA = atoi(temp) * 10 + VA % 10;
                    return RA;
                }
                PI = 2;
                return 0;
            }
            
            void EXECUTE_USER_PROGRAM()
            {
                char opcode[3], operand[2];
                int locIR, RA;
            
                while (true)
                {
                    if (flagBreak)
                        break;
            
                    RA = ADDRESSMAP(IC);
                    if (PI != 0)
                    {
                        if (MOS())
                        {
                            continue;
                        }
                        break;
                    }
                    memcpy(IR, M[RA], 4);
                    IC += 1;
            
                    memset(opcode, '\0', 3);
                    memcpy(opcode, IR, 2);
                    for (int i = 0; i < 2; i++)
                    {
                        if (!((47 < IR[i + 2] && IR[i + 2] < 58) || IR[i + 2] == 0))
                        {
                            PI = 2;
                            break;
                        }
                        operand[i] = IR[i + 2];
                    }
            
                    if (PI != 0)
                    {
                        MOS();
                        break;
                    }
            
                    locIR = atoi(operand);
            
                    RA = ADDRESSMAP(locIR);
                    if (PI != 0)
                    {
                        if (MOS())
                        {
                            IC--;
                            continue;
                        }
                        break;
                    }
            
                    if (!strcmp(opcode, "LR"))
                    {
            
                        cout << endl;
                        for (int i = 0; i < 4; i++)
                        {
                            R[i] = M[RA][i];
                        }
                        increment();
                    }
                    else if (!strcmp(opcode, "SR"))
                    {
            
                        for (int i = 0; i < 4; i++)
                        {
                            M[RA][i] = R[i];
                        }
                        TTC = TTC + 2;
                        if (TTC + 2 > pcb.TTL)
                        {
                            TI = 2;
                        }
                    }
                    else if (!strcmp(opcode, "CR"))
                    {
            
                        if (!strcmp(R, M[RA]))
                            C = 1;
                        else
                            C = 0;
                        increment();
                    }
                    else if (!strcmp(opcode, "BT"))
                    {
            
                        if (C == 1)
                            IC = RA;
                        increment();
                    }
                    else if (!strcmp(opcode, "GD"))
                    {
                        SI = 1;
                        TTC = TTC + 2;
                        if (TTC + 2 > pcb.TTL)
                        {
                            TI = 2;
                        }
                        MOS(RA);
                    }
                    else if (!strcmp(opcode, "PD"))
                    {
                        SI = 2;
                        increment();
                        MOS(RA);
                    }
                    else if (!strcmp(opcode, "H"))
                    {
                        SI = 3;
                        increment();
                        MOS();
            
                        break;
                    }
                    else
                    {
                        PI = 1;
                        MOS();
                        break;
                    }
                    memset(IR, '\0', 4);
                }
                // for(int i=0; i< 300; i++){
                //                 cout<< i< <" ";
                //             for(int j=0 ; j< 4; j++){
                //                 cout<< M[i][j]<<" ";
                //             }
                //             cout<< endl;
                //         }
            }
            
            void STARTEXECUTION()
            {
                IC = 0;
                EXECUTE_USER_PROGRAM();
            }
            
            int ALLOCATE()
            {
                int random = rand() % 30;
                if (allo.size() == 0)
                {
                    allo.push_back(random);
                    return allo[0];
                }
                for (int i = 0; i < allo.size(); i++)
                {
                    if (random == allo[i])
                    {
                        return ALLOCATE();
                    }
                }
                allo.push_back(random);
            
                return allo[allo.size() - 1];
            }
            
            void LOAD()
            {
                int m;        // Variable to hold memory loction
                int currPTR;  // Points to the last empty loction in Page Table Register
                char temp[5]; // Temporary Variable to check for $AMJ, $DTA, $END
                memset(buffer, '\0', 40);
            
                while (!fin.eof())
                {
                    fin.getline(buffer, 41);
                    memset(temp, '\0', 5);
                    memcpy(temp, buffer, 4);
            
                    if (!strcmp(temp, "$AMJ"))
                    { // if 0 then false (strcmp=0 if same)
                        INIT();
                        srand(time(0));
                        int jobId, TTL, TLL;
                        memcpy(temp, buffer + 4, 4);
                        jobId = atoi(temp);
                        memcpy(temp, buffer + 8, 4);
                        TTL = atoi(temp);
                        memcpy(temp, buffer + 12, 4);
                        TLL = atoi(temp);
                        pcb.setPCB(jobId, TTL, TLL);
                        TTC = 0;
                        LLC = 0;
                        PTR = ALLOCATE() * 10;
            
                        memset(M[PTR], '*', 40);
                        for (int i = 0; i < 10; i++)
                        {
                            M[PTR + i][0] = '0';
                        }
                        currPTR = PTR;
                    }
                    else if (!strcmp(temp, "$DTA"))
                    {
                        STARTEXECUTION();
                    }
                    else if (!strcmp(temp, "$END"))
                    {
                        continue;
                    }
                    else
                    {
                        if (flagBreak)
                            continue;
            
                        do
                        {
                            m = ALLOCATE();
                        } while (M[m * 10][0] != '\0');
                        char temp[2];
                        sprintf(temp, "%d", m);
                        M[currPTR][0] = '1'; // flag set
            
                        if (m < 10)
                        {
                            M[currPTR][2] = '0';
                            M[currPTR][3] = temp[0];
                        }
                        else
                        {
                            M[currPTR][2] = temp[0];
                            M[currPTR][3] = temp[1];
                        }
            
                        currPTR++;
            
                        strcpy(M[m * 10], buffer);
            
                        cout << "PTR = " << PTR << endl;
            
                        cout << endl;
                    }
                }
            }
            
            int main()
            {
                LOAD();
                cout << "Execution Completed!";
                fin.close();
                fout.close();
                return 0;
            }
        </div>
  </body>
</html>
